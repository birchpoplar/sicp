#+TITLE: SICP Book - Notes & Code
#+AUTHOR: Johnnie Walker
#+PROPERTY: header-args :eval yes
#+PROPERTY: header-args:racket :lang sicp

* Chapter 1 - Building Abstractions with Procedures

** 1.1 Elements of Programming

Simple program to test functionality:

#+begin_src racket :lang sicp
    (inc 45)
#+end_src

#+RESULTS:
: 46

*Combination*: delimited list of expressions within parentheses to denote procedure application.

*Prefix Notation*: useful when a procedure can take an arbitrary number of arguments. Also allows nesting of procedures.

#+BEGIN_SRC racket
  (define pi 3.14159)
  (define radius 10) 

  (* pi (* radius radius))

  (define circumference (* 2 pi radius))

  circumference

#+END_SRC

#+RESULTS:
: 62.8318

Can evaluate primitive expressions. For example evaluating a numeral is the number it names. Then there are special forms, e.g. ~define~, which associates a name with a value.

*** 1.1.4 Compound Procedures
Elements of a powerful programming language (as far as we have learnt about Lisp so far):
1. numbers and arithmetic operations are primitive data and procedures, there is a fundamental ability to represent values and operating on those values
2. Can combine operations via nesting
3. Ability to abstract by associating names with values (and operations)

*Syntactic sugar* refers to language features or constructs that make code easier to read or write, without adding new functionality to the language itself. These constructs are "sugar" because they make the syntax "sweeter" for the programmer, improving clarity and reducing verbosity.

*** 1.1.5 Substitution Model

#+begin_src racket

  (define (square x) (* x x))

  (define (sum-of-squares x y)
    (+ (square x) (square y)))

  (define (f a)
    (sum-of-squares (+ a 1) (* a 2)))

  (f 5)

#+end_src

#+RESULTS:
: 136

Substitution model breaks down when used with "mutable data" and procedures.

Applicative-order execution:
- typical approach for interpreters
- evaluate the body of the procedure with the formal parameters replaced by the corresponding argument
- Often has efficiency over the normal-order method as less repetitive execution (evaluations lead to multiple uses of the resulting value)
- Lisp uses applicative order execution

Normal-order execution:
- replace and substitute until no further substitution can be done, then evaluate
- Can become a lot more complicated when substitution not feasible

Normal-order = fully expand and then reduce.
Applicative-order = evaluate the arguments and then apply.

*** 1.1.6 Conditional Expressions and Predicates

**** Case and If Statements
Sequence of predicates and expressions. The predicates are evaluated until one is found true and then the consequent expression value returned.

Various conditional expression examples:

#+begin_src racket :lang sicp
  (define (abs x)
    (cond ((> x 10) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (abs 4)
#+end_src

#+RESULTS:
: #<void>

#+begin_src racket :lang sicp
  (define (abs x)
    (cond ((< x 0) (- x))
          (else x)))
  
  (abs -6)
#+end_src

#+RESULTS:
: 6

~if~ is a special restricted type of conditional that can be used when precisely two cases in the case analysis exist or are needed.

#+begin_src racket :lang sicp
  (define (abs x)
    (if (< x 0)
        (- x)
        x))

  (abs -10)
#+end_src

#+RESULTS:
: 10

Built in ~if~ is a special form. Based on the result of the predicate it only evaluates one of the two branches.

**** Logical Expressions

Tested the exercises in the Racket REPL. See exercises

*** 1.1.7 Example: Square Roots by Newton's Method

*Principle*: In mathematics we are usually concerned with the declarative description, whereas in computer science we are concerned with the imperative description. One defines properties, the other describes how to do things.

*Note*: with AI code generation, feasible for high-level languages to be declerative, and leave the actual how-to or imperative programming to the AI.

#+begin_src racket :lang sicp
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (average x y)
    (/ (+ x y) 2))

  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))

  (define (sqrt x)
    (sqrt-iter 1.0 x))

  (define (square x)
    (* x x))

    (sqrt (+ 100 37))

#+end_src

#+RESULTS:
: 11.704699917758145

*** 1.1.8 Procedures as Black Box Abstractions

Decomposition is the breaking down of a problem into subproblems.

The crucial aspect is to break down into procedures that accomplish a specifically defined tasks such that they can be used by other procedures. It then abstracts the /how/ and we're concerned only with the /what/.

*Bound variables* are formal parameters for which their use is independent of their name. The bound variable has scope within the procedure that binds it.

If a variable is not bound it is free.

*Therefore, the formal parameters of a procedure are local to that procedure.*

Using a *block structure* it is possible to nest definitions within a procedure. This then avoids proliferation of multiple similar and possibly (probably) conflicting subprocedures across an application.

*Block structure* also allows lexical scoping (or enables lexical scoping) such that commonly referenced or passed variables can be free within the scope of the block strucure, and not visible outwith the structure. The solves for the name-packaging problem, where conflicting names for different variables can (and frequently would) occur.

*Recursive process*: characterized by a chain of deferred processes, an interpreter must keep track of the processes to be completed later on. If the amount of information needing tracked increases linearly with the function parameter then it is a /linearly recursive process/.

*Iterative process*: this is one where maintaining the state requires knowledge of a series of state variables. Using those variables you can re-create any particular stage or stages of the process. SImilarly if the number of iterations grows linearly with the function parameter then it is a /linearly iterative process/.

Iterative processes can be restarted just by knowing the value of the state variables. Recursive processes require the full chain to occur.

A recursive procedure is one that refers to itself. Such a procedure may still result in an iterative process.

* Template for LaTeX figure in source block
#+name: circle
#+header: :results file drawer
#+header: :file circle.png
#+header: :imagemagick yes
#+header: :headers '("\\usepackage{tikz}")
#+begin_src latex
  \begin{tikzpicture}
      \fill[red] (0,0) circle (3cm);
    \end{tikzpicture}
#+end_src

#+RESULTS: circle
:results:
[[file:circle.png]]
:end:
